@startuml
start
:前端发送抢购请求;
:后端接受抢购求请求;
if(判断该商品对应的场次是否存在并且该商品对应的抢购活动是不是进行中) then (no)
    :抛出该商品抢购活动还未开始异常信息;
elseif(判断该用户已经抢购购过该商品的数量（分为抢购资格数量和已购数量）
        是否已经超过该商品抢购限制数量) then (yes)
    :抛出抢购数量超出该商品的限制抢购数量异常信息;
elseif(抢购商品数量是否大于该商品库存) then (yes)
    :抛出抢购数量大于该商品库存数量异常信息;
else
:发送mq消息，异步处理生成订单快照;
:返回成功信息，前端页面跳转抢购排队等待页面;
endif
stop

start
:排队等待页面定时查询后端相关接口;
if(排队等待页面定时调用后台接口查询该会员抢购该商品的资格是否存在
    （首先判断是否有抢购资格资格，如果没有，在查询对应商品库存是否大于零）) then(yes);
                :排队等待页面跳转到订单确认页面;
endif
stop

start
:异步处理生成订单快照;
if(判断该商品对应的场次是否存在并且该商品对应的抢购活动是不是进行中) then (no)
    :抛出该商品抢购活动还未开始异常信息;
elseif(判断该用户已经抢购过该商品的数量（分为抢购资格数量和已抢购数量）
        是否已经超过该商品抢购限制数量) then (yes)
    :抛出抢购数量超出该商品的限制抢购数量异常信息;
elseif(抢购商品数量是否大于该商品库存) then (yes)
    :抛出抢购数量大于该商品库存数量异常信息;
else
:扣减商品库存;
    if(扣减库存成功) then (yes)
        :生成订单快照信息(按原先生成快照处理);
        :同时将该用户的"qualifications:"+customerId+抢购活动Id作为抢购资格缓存redis的key，
            value对应该会员抢购该商品的数量，以及对应的快照id,失效时间为五分钟;
        :通过RabbitMQ的TTL和DLX（实现延迟队列）处理已经获得抢购资格但没有下单的商品，
            将对应的商品的商品库存进行增加相应的商品数量;
    endif
endif
stop

start
:抢购商品下单(整个方法加锁（key为"lock:"+customerId+抢购活动Id）);
if(判断该商品对应的场次是否存在并且该商品对应的抢购活动是不是进行中) then (no)
    :抛出该商品抢购活动还未开始异常信息;
elseif(判断该用户已经抢购过该商品的数量（分为抢购资格数量和已抢购数量）
        是否已经超过该商品抢购限制数量) then (yes)
    :抛出抢购数量超出该商品的限制抢购数量异常信息;
elseif(抢购商品数量是否大于该商品库存) then (yes)
    :抛出抢购数量大于该商品库存数量异常信息;
elseif(抢购资格是否有效) then (yes)
    :原先正常商品下单流程;
    :增加订单类型为抢购商品类型订单的字段标志;
    :扣库存逻辑修改，如果是抢购商品订单则不走原先扣库存逻辑,扣秒杀商品表库存;
    :redis缓存已下单抢购商品数量，key为"havePanicBuying:"+customerId+抢购活动Id,value为历史抢购数量总和;
else
    :抛出抢购资格失效异常;
endif
stop


@enduml